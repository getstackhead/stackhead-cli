package ansible

import (
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/getstackhead/stackhead/cli/stackhead"
)

// InventoryOptions is a configuration used during creation of the temporary inventory file
type InventoryOptions struct {
	IPAddress                  string
	ProjectDefinitionFile      string
	ProjectDefinitionFileName  string
	TmpProjectDefinitionFolder string
	Webserver                  string
	Container                  string
	Plugins                    []string
}

// IPAddress sets the corresponding inventory option
func IPAddress(ipAddress string) InventoryOption {
	return func(args *InventoryOptions) {
		args.IPAddress = ipAddress
	}
}

// ProjectDefinitionFile sets the corresponding inventory option
func ProjectDefinitionFile(projectDefinitionFile string) InventoryOption {
	return func(args *InventoryOptions) {
		args.ProjectDefinitionFile = projectDefinitionFile
	}
}

// InventoryOption is a single inventory setting
type InventoryOption func(*InventoryOptions)

func copyFile(srcPath string, destPath string) error {
	input, err := ioutil.ReadFile(srcPath)
	if err != nil {
		return err
	}

	if err = ioutil.WriteFile(destPath, input, 0600); err != nil {
		return err
	}
	return nil
}

// CreateInventoryFile creates a temporary inventory file with the given settings and returns an absolute file path.
// Note: make sure to remove the file when you don't need it anymore!
func CreateInventoryFile(options ...InventoryOption) (string, error) {
	opts := &InventoryOptions{}
	for _, setter := range options {
		setter(opts)
	}

	tmpFile, err := ioutil.TempFile("", "inventory")
	if err != nil {
		return "", err
	}

	filePath, err := filepath.Abs(tmpFile.Name())
	if err != nil {
		os.Remove(tmpFile.Name())
		return "", err
	}

	opts.Webserver, err = stackhead.GetWebserverModule()
	if err != nil {
		return "", err
	}
	opts.Container, err = stackhead.GetContainerModule()
	if err != nil {
		return "", err
	}
	opts.Plugins, err = stackhead.GetPluginModules()
	for i := range opts.Plugins {
		opts.Plugins[i] = "\"" + opts.Plugins[i] + "\""
	}
	if err != nil {
		return "", err
	}

	if len(opts.ProjectDefinitionFile) > 0 {
		opts.TmpProjectDefinitionFolder, err = ioutil.TempDir("", "project_definitions")
		if err != nil {
			return "", err
		}
		projectDefinitionFile := filepath.Base(opts.ProjectDefinitionFile)

		// Copy project definition file
		err = copyFile(opts.ProjectDefinitionFile, filepath.Join(opts.TmpProjectDefinitionFolder, projectDefinitionFile))
		if err != nil {
			return "", err
		}

		opts.ProjectDefinitionFileName = projectDefinitionFile
		opts.ProjectDefinitionFileName = strings.TrimSuffix(opts.ProjectDefinitionFileName, ".yml")
		opts.ProjectDefinitionFileName = strings.TrimSuffix(opts.ProjectDefinitionFileName, ".yaml")
	}

	t := template.New("ansible_inventory")
	t = t.Funcs(template.FuncMap{"StringsJoin": strings.Join})

	t, err = t.Parse(`# This file was generated by StackHead.
---
all:
  vars:
    ansible_user: root
    ansible_connection: ssh
    stackhead__config_folder: "{{ .TmpProjectDefinitionFolder }}"
    stackhead__webserver: "{{ .Webserver }}"
    stackhead__container: "{{ .Container }}"
    stackhead__plugins: [{{ StringsJoin .Plugins "," }}]
    ansible_python_interpreter: /usr/bin/python3
  hosts:
    mackerel:
      ansible_host: {{ .IPAddress }}
      stackhead:
        applications:
          - {{ .ProjectDefinitionFileName }}
`)
	if err != nil {
		return "", err
	}

	if err = t.Execute(tmpFile, opts); err != nil {
		return "", err
	}

	// Close the file
	if err = tmpFile.Close(); err != nil {
		return "", err
	}

	return filePath, nil
}
